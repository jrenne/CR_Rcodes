# ===============================================
# SECO project - LOW INTEREST RATES
#
# Philippe Bacchetta, Kenza Benhima,
# Jean-Paul Renne.
# ===============================================
#
# This script produces inflation forecasts
#
# ===============================================

# clear workspace:
rm(list = ls())

# Specify whether forecasts are used or not:
indic.include.forecasts <- 1

# Re-estimate model parameters:
indic.estim <- 0
# In case of re-estimation, save results:
indic.save.results.ExpInfl <- 1

# Remove zero inflation:
indic.remove.zero.inflation <- 1
# Remove extreme values:
threshold.up <- 20
threshold.lo <- -10

# After estimation, take correlations into account:
indic.consider.correlation <- 1

# load libraries
library(forecast)
library(readxl)
library(seasonal)
library(Rcpp)
library(RcppEigen)
library(MASS)
library(stringr)
library(expm)
library(optimx)

source('procedures/procedures_fcsts.R')
source('procedures/procedures_KF.R')
sourceCpp("Kalman/kalman_inflation_cpp.cpp") # load C++ Kalman Filter

# Load R Kalman procedures (includes smoother)
source("Kalman/procedures_smoother.R")

frequency                <- 4 # Number of periods per year, i.e. 4 for quarterly
horizons.in.year         <- 5 # for preliminary chart
horizons.4.chart.in.year <- c(1,2,5,10) # for saved data and chart
horizon                  <- horizons.in.year * frequency
horizons.4.chart         <- horizons.4.chart.in.year * frequency

# Minimum value for theta1:
min.theta1 <- .01

source('load.data/load.ctry.names.R')
source("load.data/load.data.CF.R")
source("load.data/load.data.5y.FCSTS.R")

if(indic.include.forecasts == 0){
  ALL.DATA[,(N+2):dim(ALL.DATA)[2]] <- NaN
}

vec.of.FCTS.horiz <- get.horiz.4.FCST(names(ALL.DATA))
vec.of.FCTS.horiz.not.in.years <- frequency * vec.of.FCTS.horiz

T <- dim(ALL.DATA)[1]

observables <- as.matrix(ALL.DATA[,2:dim(ALL.DATA)[2]]) # remove column of dates
stop()


observables[(observables>threshold.up)|observables<threshold.lo] <- NaN


THETA.FULL  <- c(.2, # std dev of long-run component innovation
                 .1, # std dev of cyclical component
                 log(.9/(1 - .9)), # determines auto-regressive parameter
                 3, # std dev of volatile component  (start of sample)
                 log(5), # This is log(-theta0)
                 log(.025 - min.theta1), # this is log(theta1)
                 .05,  # std dev of CF measurement errors (horiz.<2y)
                 .05 # std dev of CF measurement errors (horiz.= 5y)
)

SSpace <- theta.2.model(THETA.FULL,
                        n=length(list.of.ctries),
                        T,
                        vec.of.FCTS.horiz.not.in.years,
                        info.regarding.5y.FCST)


res.KF <- KF_filter_inflation_cpp(observables,SSpace)
#res.KS <- Kalman_smoother(observables,SSpace,indic.inflation = 1)

# Check log-Lik function:
FILTER <- rep(1,length(THETA.FULL))
theta  <- THETA.FULL[FILTER==1]
logl   <- Loglik.4.optim.ExpInfl(theta,
                                 THETA.FULL,
                                 FILTER,
                                 vec.of.FCTS.horiz.not.in.years,
                                 info.regarding.5y.FCST,
                                 observables)
print(paste("Loglik before estimation: ",
            toString(round(res.KF$loglik,2))," (Check: ",
            toString(round(logl,2)),")",sep=""))


file.save.name <- paste("../Outputs/parameterizations/paramExpInfl_",
                        ifelse(indic.include.forecasts==1,
                               "withFCSTS","withoutFCSTS"),
                        ".Rdat",sep="")
if(indic.estim == 1){
  FILTER <- c(0,1,1,0,0,1,0,0)
  nb.loops     <- 2
  MAXIT.NldMd  <- 100
  MAXIT.nlminb <- 10
  theta.ini <- THETA.FULL[FILTER==1]
  source("estimation/run.optim.ExpInfl.R")
  THETA.FULL[FILTER==1] <- theta.ini
  if(indic.save.results.ExpInfl == 1){
    save(THETA.FULL,
         min.theta1,
         file=file.save.name)
  }
}else{
  load(file=file.save.name)
}

# Prepare table with parameters:
source("make.outputs/make.table.param.InflExp.R")

SSpace <- theta.2.model(THETA.FULL,N,
                        T = dim(observables)[1],
                        vec.of.FCTS.horiz.not.in.years,
                        info.regarding.5y.FCST)
res.KF <- KF_filter_inflation_cpp(observables,SSpace)

print(paste("Loglik after estimation: ",
            toString(round(res.KF$loglik,2)),sep=""))

if(indic.consider.correlation == 1){
  # Determine dates to consider to compute correlatins:
  data.aux <- observables[,1:N]
  aux.detect.not.na <- which(!is.na(apply(data.aux,1,sum)))
  
  # Modify correlation structure of latent variables:
  estimated.factors <- t(res.KF$W.updated)
  estimated.innov.factors <- estimated.factors[2:T,] - SSpace$nu_t[2:T,] -
    estimated.factors[1:(T-1),] %*% t(SSpace$H)
  correl.betas <- cor(estimated.innov.factors[aux.detect.not.na-1,])
  Omega      <- (SSpace$N) %*% t(SSpace$N)
  Omega_star <- diag(sqrt(diag(Omega))) %*% correl.betas %*% t(diag(sqrt(diag(Omega))))
  N_star     <- t(chol(Omega_star))
  
  SSpace$N   <- N_star
  res.KF <- KF_filter_inflation_cpp(observables,SSpace)
  
  print(paste("Loglik after adding correlations: ",
              toString(round(res.KF$loglik,2)),sep=""))
  
}



#Latent.factors <- t(res.KS$r_smooth)
Latent.factors <- t(res.KF$W.updated)

Fcsts <- make.forecasts.in.years(SSpace,
                                 k=frequency,
                                 max.Horizon.in.years=20,
                                 t(Latent.factors))

par(mfrow=c(3,6))
par(plt=c(.1,.95,.1,.8))
for(i in 1:N){
  plot(ALL.DATA$Dates,res.KF$W.updated[i,],type="l",
       main=list.of.ctries[i],ylim=c(-10,15))
  if(i<N+1){
    points(ALL.DATA$Dates,observables[,i],col="blue",pch=19)
    #lines(ALL.DATA$Dates,res.KS$r_smooth[,i],col="green")
    lines(ALL.DATA$Dates,Fcsts$all.fcsts[[horizons.in.year]][i,],col="red")
    abline(h=0,col="grey")
    abline(h=2,col="grey")
  }
}

var.of.volatile.component <- SSpace$M[1,1] * 1/(1+exp(SSpace$theta0+SSpace$theta1*(0:(T-1))))
plot(sqrt(var.of.volatile.component),type="l")

# Produce charts
source("make.outputs/make.figures.InflExp.R")
source("make.outputs/make.figure.Switzerland.R")


